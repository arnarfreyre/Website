<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Game Debug Console</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #fff;
            margin: 0;
            padding: 20px;
            line-height: 1.6;
        }
        
        .debug-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            color: #6d8ad0;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .debug-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .debug-section {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
        }
        
        .debug-section h2 {
            color: #6d8ad0;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 10px;
        }
        
        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .data-label {
            color: #999;
        }
        
        .data-value {
            color: #fff;
            font-weight: bold;
        }
        
        .data-value.good { color: #0f0; }
        .data-value.warning { color: #ff0; }
        .data-value.bad { color: #f00; }
        .data-value.ice { color: #00ffff; }
        
        #levelGrid {
            font-family: monospace;
            font-size: 12px;
            line-height: 1.2;
            white-space: pre;
            overflow-x: auto;
            background: #000;
            padding: 10px;
            border-radius: 4px;
        }
        
        .tile-empty { color: #333; }
        .tile-platform { color: #fff; }
        .tile-spike { color: #f00; }
        .tile-goal { color: #ff0; }
        .tile-ice { color: #00ffff; }
        .tile-bounce { color: #f0f; }
        .tile-player { color: #0f0; background: rgba(0, 255, 0, 0.2); }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        button {
            background: #4c6baf;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
        }
        
        button:hover {
            background: #5a7cc0;
        }
        
        button:active {
            background: #3a5189;
        }
        
        #logOutput {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }
        
        .log-time {
            color: #666;
            margin-right: 10px;
        }
        
        .log-info { color: #6d8ad0; }
        .log-warning { color: #ff0; }
        .log-error { color: #f00; }
        
        #performanceGraph {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            margin-top: 10px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-active { background: #0f0; }
        .status-inactive { background: #666; }
        .status-error { background: #f00; }
        
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }
        
        .action-buttons button {
            width: 100%;
            font-size: 12px;
            padding: 8px 10px;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <h1>Pixel Platformer Debug Console</h1>
        
        <div class="controls">
            <button onclick="connectToGame()">Connect to Game</button>
            <button onclick="refreshData()">Refresh Data</button>
            <button onclick="clearLogs()">Clear Logs</button>
            <button onclick="exportDebugData()">Export Debug Data</button>
            <span id="connectionStatus">
                <span class="status-indicator status-inactive"></span>
                Disconnected
            </span>
        </div>
        
        <div class="debug-grid">
            <!-- Game State -->
            <div class="debug-section">
                <h2>Game State</h2>
                <div id="gameStateData">
                    <div class="data-row">
                        <span class="data-label">Status:</span>
                        <span class="data-value">Not connected</span>
                    </div>
                </div>
            </div>
            
            <!-- Player State -->
            <div class="debug-section">
                <h2>Player State</h2>
                <div id="playerStateData">
                    <div class="data-row">
                        <span class="data-label">Status:</span>
                        <span class="data-value">No data</span>
                    </div>
                </div>
            </div>
            
            <!-- Physics Data -->
            <div class="debug-section">
                <h2>Physics & Movement</h2>
                <div id="physicsData">
                    <div class="data-row">
                        <span class="data-label">Status:</span>
                        <span class="data-value">No data</span>
                    </div>
                </div>
            </div>
            
            <!-- Performance Metrics -->
            <div class="debug-section">
                <h2>Performance</h2>
                <div id="performanceData">
                    <div class="data-row">
                        <span class="data-label">FPS:</span>
                        <span class="data-value">--</span>
                    </div>
                </div>
                <canvas id="performanceGraph" width="380" height="150"></canvas>
            </div>
            
            <!-- Level Info -->
            <div class="debug-section" style="grid-column: span 2;">
                <h2>Level Visualization</h2>
                <div id="levelInfo">
                    <div class="data-row">
                        <span class="data-label">Current Level:</span>
                        <span class="data-value">--</span>
                    </div>
                </div>
                <div id="levelGrid">No level data</div>
            </div>
            
            <!-- Debug Actions -->
            <div class="debug-section">
                <h2>Debug Actions</h2>
                <div class="action-buttons">
                    <button onclick="teleportPlayer()">Teleport Player</button>
                    <button onclick="toggleGodMode()">Toggle God Mode</button>
                    <button onclick="toggleSlowMotion()">Toggle Slow Motion</button>
                    <button onclick="spawnParticles()">Spawn Particles</button>
                    <button onclick="killPlayer()">Kill Player</button>
                    <button onclick="completeLevel()">Complete Level</button>
                    <button onclick="resetLevel()">Reset Level</button>
                    <button onclick="toggleDebugOverlay()">Toggle Overlay</button>
                </div>
            </div>
            
            <!-- Console Log -->
            <div class="debug-section">
                <h2>Debug Log</h2>
                <div id="logOutput"></div>
            </div>
        </div>
    </div>
    
    <script>
        let gameWindow = null;
        let isConnected = false;
        let updateInterval = null;
        let fpsHistory = [];
        let performanceCtx = null;
        
        // Initialize performance graph
        window.onload = () => {
            const canvas = document.getElementById('performanceGraph');
            performanceCtx = canvas.getContext('2d');
            performanceCtx.strokeStyle = '#0f0';
            performanceCtx.lineWidth = 2;
        };
        
        function connectToGame() {
            // Try to find the game window
            gameWindow = window.opener || window.parent;
            
            if (gameWindow && gameWindow !== window) {
                try {
                    // Check if we can access the game
                    if (gameWindow.gameManager) {
                        isConnected = true;
                        updateConnectionStatus(true);
                        log('Connected to game successfully', 'info');
                        
                        // Start auto-refresh
                        if (updateInterval) clearInterval(updateInterval);
                        updateInterval = setInterval(refreshData, 100);
                        
                        // Initial data fetch
                        refreshData();
                    } else {
                        log('Game manager not found in window', 'error');
                        updateConnectionStatus(false);
                    }
                } catch (e) {
                    log('Cannot access game window: ' + e.message, 'error');
                    updateConnectionStatus(false);
                }
            } else {
                log('No game window found. Open this console from the game.', 'warning');
                updateConnectionStatus(false);
            }
        }
        
        function updateConnectionStatus(connected) {
            const statusEl = document.getElementById('connectionStatus');
            const indicator = statusEl.querySelector('.status-indicator');
            
            if (connected) {
                indicator.className = 'status-indicator status-active';
                statusEl.innerHTML = '<span class="status-indicator status-active"></span>Connected';
            } else {
                indicator.className = 'status-indicator status-inactive';
                statusEl.innerHTML = '<span class="status-indicator status-inactive"></span>Disconnected';
            }
        }
        
        function refreshData() {
            if (!isConnected || !gameWindow || !gameWindow.gameManager) {
                updateConnectionStatus(false);
                return;
            }
            
            try {
                const gm = gameWindow.gameManager;
                const gs = gm.gameState;
                
                // Update game state
                updateGameState(gs);
                
                // Update player state
                if (gs.player) {
                    updatePlayerState(gs.player);
                    updatePhysicsData(gs.player);
                }
                
                // Update performance
                updatePerformanceData(gm.renderer);
                
                // Update level visualization
                if (gs.currentLevel) {
                    updateLevelVisualization(gs.currentLevel, gs.player);
                }
                
            } catch (e) {
                log('Error updating data: ' + e.message, 'error');
                updateConnectionStatus(false);
            }
        }
        
        function updateGameState(gameState) {
            const stateNames = {
                0: 'MENU',
                1: 'PLAYING',
                2: 'PAUSED',
                3: 'GAME_OVER',
                4: 'LEVEL_COMPLETE',
                5: 'LEVEL_SELECT',
                6: 'SETTINGS'
            };
            
            const html = `
                <div class="data-row">
                    <span class="data-label">State:</span>
                    <span class="data-value">${stateNames[gameState.state] || 'UNKNOWN'}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Level Time:</span>
                    <span class="data-value">${gameState.levelTime.toFixed(2)}s</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Deaths:</span>
                    <span class="data-value ${gameState.deaths > 10 ? 'bad' : gameState.deaths > 5 ? 'warning' : 'good'}">${gameState.deaths}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Particles:</span>
                    <span class="data-value">${gameState.particles.length}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Keys Pressed:</span>
                    <span class="data-value">${Object.keys(gameState.keys).filter(k => gameState.keys[k]).join(', ') || 'None'}</span>
                </div>
            `;
            
            document.getElementById('gameStateData').innerHTML = html;
        }
        
        function updatePlayerState(player) {
            const html = `
                <div class="data-row">
                    <span class="data-label">Position:</span>
                    <span class="data-value">(${Math.round(player.x)}, ${Math.round(player.y)})</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Grid Position:</span>
                    <span class="data-value">(${Math.floor(player.x / 32)}, ${Math.floor(player.y / 32)})</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Alive:</span>
                    <span class="data-value ${player.alive ? 'good' : 'bad'}">${player.alive}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Grounded:</span>
                    <span class="data-value ${player.grounded ? 'good' : 'warning'}">${player.grounded}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">On Ice:</span>
                    <span class="data-value ${player.onIce ? 'ice' : ''}">${player.onIce}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Current Tile:</span>
                    <span class="data-value">${player.currentTile?.name || 'None'}</span>
                </div>
            `;
            
            document.getElementById('playerStateData').innerHTML = html;
        }
        
        function updatePhysicsData(player) {
            const speed = Math.sqrt(player.velX * player.velX + player.velY * player.velY);
            
            const html = `
                <div class="data-row">
                    <span class="data-label">Velocity X:</span>
                    <span class="data-value">${player.velX.toFixed(2)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Velocity Y:</span>
                    <span class="data-value">${player.velY.toFixed(2)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Speed:</span>
                    <span class="data-value">${speed.toFixed(2)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Friction:</span>
                    <span class="data-value">${player.friction.toFixed(3)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Max Speed:</span>
                    <span class="data-value">${player.maxSpeed}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Ice Time:</span>
                    <span class="data-value ${player.onIce ? 'ice' : ''}">${player.iceTime.toFixed(1)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Ice Inertia:</span>
                    <span class="data-value">${player.iceInertia.toFixed(2)}</span>
                </div>
            `;
            
            document.getElementById('physicsData').innerHTML = html;
        }
        
        function updatePerformanceData(renderer) {
            const fps = renderer ? renderer.fps : 0;
            
            // Update FPS history
            fpsHistory.push(fps);
            if (fpsHistory.length > 100) {
                fpsHistory.shift();
            }
            
            const avgFps = fpsHistory.reduce((a, b) => a + b, 0) / fpsHistory.length;
            
            const html = `
                <div class="data-row">
                    <span class="data-label">Current FPS:</span>
                    <span class="data-value ${fps < 30 ? 'bad' : fps < 50 ? 'warning' : 'good'}">${fps}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Average FPS:</span>
                    <span class="data-value">${avgFps.toFixed(1)}</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Frame Time:</span>
                    <span class="data-value">${fps > 0 ? (1000/fps).toFixed(2) : '--'}ms</span>
                </div>
            `;
            
            document.getElementById('performanceData').innerHTML = html;
            
            // Update graph
            drawPerformanceGraph();
        }
        
        function drawPerformanceGraph() {
            if (!performanceCtx) return;
            
            const canvas = performanceCtx.canvas;
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            performanceCtx.fillStyle = '#000';
            performanceCtx.fillRect(0, 0, width, height);
            
            // Draw grid
            performanceCtx.strokeStyle = '#333';
            performanceCtx.lineWidth = 1;
            
            // Horizontal lines
            for (let i = 0; i <= 60; i += 20) {
                const y = height - (i / 60) * height;
                performanceCtx.beginPath();
                performanceCtx.moveTo(0, y);
                performanceCtx.lineTo(width, y);
                performanceCtx.stroke();
                
                // Label
                performanceCtx.fillStyle = '#666';
                performanceCtx.font = '10px Arial';
                performanceCtx.fillText(i + ' FPS', 5, y - 2);
            }
            
            // Draw FPS line
            if (fpsHistory.length > 1) {
                performanceCtx.strokeStyle = '#0f0';
                performanceCtx.lineWidth = 2;
                performanceCtx.beginPath();
                
                for (let i = 0; i < fpsHistory.length; i++) {
                    const x = (i / (fpsHistory.length - 1)) * width;
                    const y = height - (fpsHistory[i] / 60) * height;
                    
                    if (i === 0) {
                        performanceCtx.moveTo(x, y);
                    } else {
                        performanceCtx.lineTo(x, y);
                    }
                }
                
                performanceCtx.stroke();
            }
        }
        
        function updateLevelVisualization(level, player) {
            const tileSymbols = {
                0: '·', // Empty
                1: '█', // Platform
                2: '▲', // Spike
                3: '★', // Goal
                4: '█', // Dirt
                5: '█', // Wood
                6: '█', // Stone
                7: '≈', // Ice
                8: '◊', // Bounce
                9: 'P', // Player start
                10: '▲', // Spike up
                11: '►', // Spike right
                12: '▼', // Spike down
                13: '◄', // Spike left
                14: '✦', // Sawblade
                15: '▫'  // Decorative
            };
            
            const tileClasses = {
                0: 'tile-empty',
                1: 'tile-platform',
                2: 'tile-spike',
                3: 'tile-goal',
                4: 'tile-platform',
                5: 'tile-platform',
                6: 'tile-platform',
                7: 'tile-ice',
                8: 'tile-bounce',
                9: 'tile-platform',
                10: 'tile-spike',
                11: 'tile-spike',
                12: 'tile-spike',
                13: 'tile-spike',
                14: 'tile-spike',
                15: 'tile-platform'
            };
            
            let gridHtml = '';
            
            for (let y = 0; y < level.length; y++) {
                for (let x = 0; x < level[y].length; x++) {
                    const tileId = level[y][x];
                    const symbol = tileSymbols[tileId] || '?';
                    const cssClass = tileClasses[tileId] || '';
                    
                    // Check if player is on this tile
                    const playerTileX = Math.floor((player.x + player.width/2) / 32);
                    const playerTileY = Math.floor((player.y + player.height/2) / 32);
                    const isPlayerTile = x === playerTileX && y === playerTileY;
                    
                    if (isPlayerTile && player.alive) {
                        gridHtml += `<span class="tile-player">@</span>`;
                    } else {
                        gridHtml += `<span class="${cssClass}">${symbol}</span>`;
                    }
                }
                gridHtml += '\n';
            }
            
            document.getElementById('levelGrid').innerHTML = gridHtml;
            
            // Update level info
            document.getElementById('levelInfo').innerHTML = `
                <div class="data-row">
                    <span class="data-label">Level Size:</span>
                    <span class="data-value">${level[0].length} × ${level.length}</span>
                </div>
            `;
        }
        
        function log(message, type = 'info') {
            const logOutput = document.getElementById('logOutput');
            const time = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">${time}</span><span class="log-${type}">${message}</span>`;
            
            logOutput.appendChild(entry);
            logOutput.scrollTop = logOutput.scrollHeight;
            
            // Keep only last 100 entries
            while (logOutput.children.length > 100) {
                logOutput.removeChild(logOutput.firstChild);
            }
        }
        
        function clearLogs() {
            document.getElementById('logOutput').innerHTML = '';
            log('Logs cleared', 'info');
        }
        
        function exportDebugData() {
            if (!isConnected || !gameWindow || !gameWindow.gameManager) {
                log('Not connected to game', 'error');
                return;
            }
            
            try {
                const gm = gameWindow.gameManager;
                const debugData = {
                    timestamp: new Date().toISOString(),
                    gameState: {
                        state: gm.gameState.state,
                        levelTime: gm.gameState.levelTime,
                        deaths: gm.gameState.deaths,
                        particleCount: gm.gameState.particles.length
                    },
                    player: gm.gameState.player ? {
                        position: { x: gm.gameState.player.x, y: gm.gameState.player.y },
                        velocity: { x: gm.gameState.player.velX, y: gm.gameState.player.velY },
                        state: {
                            alive: gm.gameState.player.alive,
                            grounded: gm.gameState.player.grounded,
                            onIce: gm.gameState.player.onIce
                        }
                    } : null,
                    performance: {
                        fps: gm.renderer.fps,
                        fpsHistory: fpsHistory
                    }
                };
                
                const json = JSON.stringify(debugData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `platformer-debug-${Date.now()}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                log('Debug data exported', 'info');
            } catch (e) {
                log('Error exporting data: ' + e.message, 'error');
            }
        }
        
        // Debug actions
        function teleportPlayer() {
            if (!executeGameCommand('teleportPlayer')) return;
            
            const x = prompt('Enter X coordinate:');
            const y = prompt('Enter Y coordinate:');
            
            if (x !== null && y !== null) {
                try {
                    const player = gameWindow.gameManager.gameState.player;
                    player.x = parseFloat(x);
                    player.y = parseFloat(y);
                    player.velX = 0;
                    player.velY = 0;
                    log(`Teleported player to (${x}, ${y})`, 'info');
                } catch (e) {
                    log('Error teleporting player: ' + e.message, 'error');
                }
            }
        }
        
        function toggleGodMode() {
            if (!executeGameCommand('toggleGodMode')) return;
            
            try {
                const player = gameWindow.gameManager.gameState.player;
                player.godMode = !player.godMode;
                
                if (player.godMode) {
                    // Store original methods
                    player._originalCheckHorizontalCollisions = player.checkHorizontalCollisions;
                    player._originalCheckVerticalCollisions = player.checkVerticalCollisions;
                    
                    // Override with empty functions
                    player.checkHorizontalCollisions = function() {};
                    player.checkVerticalCollisions = function() {};
                } else {
                    // Restore original methods
                    if (player._originalCheckHorizontalCollisions) {
                        player.checkHorizontalCollisions = player._originalCheckHorizontalCollisions;
                        player.checkVerticalCollisions = player._originalCheckVerticalCollisions;
                    }
                }
                
                log('God mode: ' + (player.godMode ? 'ON' : 'OFF'), 'info');
            } catch (e) {
                log('Error toggling god mode: ' + e.message, 'error');
            }
        }
        
        function toggleSlowMotion() {
            if (!executeGameCommand('toggleSlowMotion')) return;
            
            try {
                const gm = gameWindow.gameManager;
                gm.slowMotion = !gm.slowMotion;
                gm.updateInterval = gm.slowMotion ? 1000 / 30 : 1000 / 60;
                log('Slow motion: ' + (gm.slowMotion ? 'ON (30 FPS)' : 'OFF (60 FPS)'), 'info');
            } catch (e) {
                log('Error toggling slow motion: ' + e.message, 'error');
            }
        }
        
        function spawnParticles() {
            if (!executeGameCommand('spawnParticles')) return;
            
            try {
                const particles = gameWindow.gameManager.gameState.particles;
                const player = gameWindow.gameManager.gameState.player;
                
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
                
                for (let i = 0; i < 50; i++) {
                    const angle = (Math.PI * 2 * i) / 50;
                    const speed = 3 + Math.random() * 3;
                    
                    particles.push({
                        x: player.x + player.width / 2,
                        y: player.y + player.height / 2,
                        size: 2 + Math.random() * 4,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        velX: Math.cos(angle) * speed,
                        velY: Math.sin(angle) * speed,
                        gravity: 0.1,
                        life: 60 + Math.random() * 60
                    });
                }
                
                log('Spawned 50 particles', 'info');
            } catch (e) {
                log('Error spawning particles: ' + e.message, 'error');
            }
        }
        
        function killPlayer() {
            if (!executeGameCommand('killPlayer')) return;
            
            try {
                const player = gameWindow.gameManager.gameState.player;
                player.alive = false;
                gameWindow.gameManager.handlePlayerDeath();
                log('Player killed', 'info');
            } catch (e) {
                log('Error killing player: ' + e.message, 'error');
            }
        }
        
        function completeLevel() {
            if (!executeGameCommand('completeLevel')) return;
            
            try {
                gameWindow.gameManager.handleLevelComplete();
                log('Level completed', 'info');
            } catch (e) {
                log('Error completing level: ' + e.message, 'error');
            }
        }
        
        function resetLevel() {
            if (!executeGameCommand('resetLevel')) return;
            
            try {
                gameWindow.gameManager.restartLevel();
                log('Level reset', 'info');
            } catch (e) {
                log('Error resetting level: ' + e.message, 'error');
            }
        }
        
        function toggleDebugOverlay() {
            if (!executeGameCommand('toggleDebugOverlay')) return;
            
            try {
                const renderer = gameWindow.gameManager.renderer;
                if (renderer.debugOverlay) {
                    const enabled = renderer.debugOverlay.toggle();
                    log('Debug overlay: ' + (enabled ? 'ON' : 'OFF'), 'info');
                } else {
                    log('Debug overlay not available', 'error');
                }
            } catch (e) {
                log('Error toggling debug overlay: ' + e.message, 'error');
            }
        }
        
        function executeGameCommand(command) {
            if (!isConnected || !gameWindow || !gameWindow.gameManager) {
                log(`Cannot execute ${command}: Not connected`, 'error');
                return false;
            }
            return true;
        }
        
        // Auto-connect if opened from game
        if (window.opener) {
            setTimeout(connectToGame, 500);
        }
    </script>
</body>
</html>